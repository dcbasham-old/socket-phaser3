// sockets will live here
// state that comes from the server and unifies the game data btwn clients

const gameRooms = {
  /* [roomKey]: {
  users: [],
  randomTasks: [],
  scores:[],
  gameScore: 0,
  players: {},
  numPlayers: 0
  }
  */
};
module.exports = (io) => {
  io.on('connection', (socket) => {
    console.log(
      `a socket connection to the server has been made: ${socket.id}`
    );
    // adding this right after connection is made. Adds us to the  room.
    socket.on('joinRoom', (roomKey) => {
      socket.join(roomKey);
    });
    // listening for the event when the key: isKeyValid is emitted from waitingRoom.
    socket.on('isKeyValid', function (input) {
      const keyArray = Object.keys(gameRooms)
        ? socket.emit('keyIsValid', input)
        : socket.emit('keyNotValid');
    }); //decides if it is valid or not
  });
  socket.on('getRoomCode', async function () {
    let key = codeGenerator();
    Object.keys(gameRooms).includes(key) ? (key = codeGenerator()) : key;
    gameRooms[key] = {
      roomKey: key,
      randomTasks: {},
      gameScore: 0,
      scores: {},
      players: {},
      numPlayers: 0,
    };
    socket.emit('roomCreated', key);
  });
};
/* 1. isKeyValid event:
When the socket.on() hears it, it uses its CB function, that takes the input that we passed this emit inside our waiting room. then, we check our state object keys to see if this game exists. If it exists, we create a new socket.emit called keyIsValid. Now we need a listener in waiting room for this */
function codeGenerator() {
  let code = '';
  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ01213456789';
  for (let i = 0; i < 5; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}
/* getRoomCode & room Created :
Inside our listener, we create a variable that stores a random code generated by the function we add below our sockets called codeGenerator. After creating this variable, we check to see if this code already exists as a room on our state object, if it does we generate a new code and save it to the variable, if not we keep the one we have. We then tell our gameRooms state object to create a new key that is our game room code and make the value an object that contains all the data we will need for out game. Lastly, we emit a new socket saying the room is created, with the roomKey attached to it. Now we must add a listener for this back in our WaitingRoom.*/
